[
["index.html", "UVA Health Sciences Library Workshops Welcome Getting Started About the Instructors", " UVA Health Sciences Library Workshops Data Services @ HSL last updated 2019-09-11 Welcome This site hosts workshop tutorial materials to support our in-person workshops targeted to researchers in the life sciences at the University of Virginia to learn R skills Getting Started These tutorials assume that you have downloaded R and RStudio. Download R for Windows or for Mac (download the latest .pkg file for your OS) Download RStudio Desktop R and RStudio are separate downloads and installations. You need R installed before you install RStudio. R is the underlying statistical computing environment, but using R alone is no fun. RStudio is a graphical integrated development environment that makes using R much easier. About the Instructors The Data Services team at the Health Sciences Library at the University of Virginia proudly hosts in-person workshops throughout the year and hosts personalized consults with UVA faculty, staff, and students to assist them with data analysis. You can find out more about us at David N Martin, MS David Martin, MS David is the Clinical Data Research Specialist at the Health Sciences Library where he consults with clinicians, nurses, and students on data analysis and programming in a number of languages. He is also a PhD candidate in the Curry School of Education researching the impacts of the No Child Left Behind policy. Email: dnm5ca@virginia.edu GitHub: github.com/dnm5ca Marieke K Jones, PhD Marieke Jones, PhD Marieke is the Research Data Specialist in the Health Sciences Library. She teaches open enrollment workshops in R, consults with researchers about statistics and data analysis, and teaches the BIMS8380 statistics course and co-teaches the BIMS8382 Data Science course. Her PhD is in Environmental Science and Policy and she conducted her dissertation research on the reproductive physiology, endocrinology, and metabolomics of an endangered wolf species. Email: marieke@virginia.edu twitter: @marieke_k_jones GitHub: github.com/mariekekjones "],
["Intro.html", "Chapter 1 Introduction to R and RStudio 1.1 Set up an R Project 1.2 R as a calculator 1.3 Functions 1.4 More Functions 1.5 DataFrames 1.6 R Packages 1.7 Inspecting Dataframes 1.8 Accessing variables 1.9 Subset a dataframe using filter() 1.10 Plots in base R 1.11 Write csv file 1.12 Saving your work and quitting R", " Chapter 1 Introduction to R and RStudio R is the underlying statistical computing environment. You can think of this like the engine of a car. That makes RStudio like the dashboard1. RStudio is an integrated development environment (IDE) that allows us to interact with R. RStudio sits on top of R and makes writing and executing R code a lot easier. We’ll be benefiting from many of the added features that come with RStudio and we will point them out as we go. 1.0.1 Panes in RStudio When you open RStudio, you will have access to R (there is no need to open R directly). Now go to the top menu to open a new R Script File –&gt; New File –&gt; R Script Great! Now you will see four panes I have mine set up as follows: Editor / script / source in the top left Console bottom left Environment/history on the top right Plots/help on the bottom right Four pane layout in RStudio On the top left is the script or editor window. This is where we are going to write all of our code. On the lower left we have the console window. This is where R is running, and this is what you would see if you opened R instead of RStudio. In this pane we can see the code we send and then the answer. The top right has the environment and history tabs. The Environment is a list of all objects that are saved in memory. The History tab shows all commands that have been run. On the bottom right hand side there’s a window with several tabs. Files shows the file structure of the working directory. Plots is where your visualizations will appear. Packages shows all of the installed packages where checked ones are loaded and unchecked packages are not loaded. Help shows information about functions. Viewer for viewing other kinds of output, like web content. 1.0.2 RStudio Global Options There is one set-up preference that I think everyone will prefer. Go to Tools –&gt; Global Options In the Code menu check the box for “Soft-wrap R source files” This wraps long lines of code on to the next line automatically so that you do not have to scroll left and right to see a long line of code. 1.1 Set up an R Project I mentioned previously that RStudio has a lot of pretty handy features. One of those is the project structure Before we can start writing code we need to set up a project so that the data and our codes will be in the same place. Go to File –&gt; New Project–&gt; New Directory. I will name mine IntroR and it will be a folder on my desktop New R Project Now we have opened up a new instance of RStudio running inside the IntroR folder. Notice on the top of the console pane and the Files pane (bottom right) that the path to the IntroR folder is specified. When we start reading in data it will be important that the code and the data are in the same place. Creating a project creates an Rproj file that runs R in that folder. If you are familiar with working directories, this process is setting the working directory for this project as this folder. Once you have a project set up, when you want to read in dataset whatever.txt, you will be able to easily specify the path pointing to whatever.txt rather than having to specify a full path. This is critical for reproducibility, and we’ll talk about that more later. 1.1.1 Download learning materials To get things arranged for later, please download the dataset we are going to use. Right click –&gt; Save link as to download the file to your computer. gapminder data set Move the dataset to your IntroR directory in a subfolder called data. File structure Now that we have a project directory and the dataset inside that project directory, make a new R script by going to File –&gt; New File –&gt; R Script. Now you too have the 4 pane layout. 1.2 R as a calculator R can be used as a calculator. Make sure you’re typing into into the editor. Do not code in the console because this work will not be saved. Use the Run button on the top of the script pane to run the code. 2 + 2 ## [1] 4 Notice the output in the console that tells us the code we wrote and the answer. Let’s try some others. 5 * 4 ## [1] 20 2 ^3 ## [1] 8 Instead of using the Run button to run code, let’s try the keyboard shortcut to run code. To send code from the editor to the console, place your cursor on a line of code and use CMD+Enter (Mac) or Ctrl+Enter (Windows). This is way faster than using your mouse to hit the Run button each time. Go back to your code above and run them using the keyboard. We can also run multiple lines of code at once. Now highlight 2 lines of code and run them together. R also knows order of operations and scientific notation. (5 + 3)^2 ## [1] 64 5 + 3^2 ## [1] 14 5e4 ## [1] 50000 1.2.1 Comments Anything after a # sign is a comment, meaning it will not be executed as code. Use them liberally to comment about what you are doing and why. Today, you can take notes about what you are learning as comments. Comments are a big part of making your work reproducible for others and for your future self when you open this script a few months from now and need to remember what you were doing. Commenting is also helpful when you’re testing things out during your analysis so that you can ‘turn off’ parts of your script. # Here is a comment # Note that anything after the # is considered a comment Let’s save our script before we get any further. Go up to File –&gt; Save As and let’s go with “intro.R” 1.2.2 Creating R objects Let’s learn to create R objects next. We assign values to objects using the assignment operator “&lt;-”. This arrow is typed with a less than sign followed by a dash. We first name the object on the left and then provide the assignment operator &lt;-, and then the value. Let’s create an object called thing1 that takes the value 55. thing1 &lt;- 55 Look in the Environment pane (top right) to see your new R object! &lt;- is the assignment operator in R. It assigns values on the right to object names on the left. Think of it like an arrow that points from the value to the object. The &lt;- is mostly similar to = but not always. Learn to use &lt;- as it is good R programming practice. Using = in place of &lt;- can lead to issues down the line. The keyboard shortcut for inserting the &lt;- operator is option + dash(Mac) and Alt + dash (Windows). Objects can be given any name such as x, current_temperature, or subject_id, but they may not have a space in the name. You want your object names to be explicit and not too long. They also cannot start with a number (2x is not valid but x2 is). R is case sensitive (e.g., thing1 is different from Thing1). Thing1 &lt;- 60 Look in the Environment pane to see that there are now 2 different thing1 objects since we used different casing in the spelling of the object names. There are some words that should not be used as object names because they represent the names of functions in R. It is best to not use function names as object names since it will be confusing to tell the difference between the object and the function (e.g., c, T, mean, data, df, weights). If in doubt, start typing the name and if RStudio suggests something it already knows, then that name is already in use. For example, it is perfectly reasonable to think that data is a great name for your dataset but as you start to type it, the autocomplete function in RStudio tells you that data already exists. data() Try to use nouns for object names, and verbs for function names to help yourself remember what each item is. When assigning a value to an object, R does not print anything. You can ask to print the value by typing the object name: thing1 ## [1] 55 We can overwrite the value of thing1 by re-assigning it thing1 &lt;- 70 #then call its name to see the object thing1 ## [1] 70 1.2.3 EXERCISE 1 Try these on your own A. You have a patient with a height (inches) of 73 and a weight (lbs) of 203. Create r objects labeled ‘height’ and ‘weight’. SHOW ANSWER A height &lt;- 73 weight &lt;- 203 height ## [1] 73 weight ## [1] 203 B. Convert ‘weight’ to ‘weight_kg’ by dividing by 2.2. Convert ‘height’ to ‘height_m’ by dividing by 39.37 SHOW ANSWER B weight_kg &lt;- weight / 2.2 height_m &lt;- height / 39.37 weight_kg ## [1] 92.27273 height_m ## [1] 1.854204 C. Calculate a new object ‘bmi’ where BMI = weight_kg / (height_m*height_m) SHOW ANSWER C bmi &lt;- weight_kg / (height_m * height_m) bmi ## [1] 26.83851 You can remove objects from the environment using the rm() function. You can do this one at a time or remove several objects at once by separating their names with ,. The broom button in the Environment pane will remove all objects from your environment. rm(weight, Thing1) # Now ask R for weight (uncomment the following line and run it) # weight # oops! you should get an error because weight no longer exists! 1.3 Functions A function is a verb; it tells R to do something. To call an R function, we call the name of the function followed directly by (). The items passed to the function inside the () are called arguments. Arguments change the way a function behaves Some functions don’t need any arguments Sys.Date() #get today&#39;s date Some functions just take a single argument. Let’s get the square root of 961. Now let’s get the square root of object1 sqrt(961) ## [1] 31 To learn more about the function, type ? and then the function’s name ?sqrt Sometimes functions have arguments that have a default value. In those cases, you can override the default value by specifying your own. For example, let’s look at the help page for the rnorm() function ?rnorm rnorm() generates random values from the normal distribution. We must supply the n argument since there is no default value, but there is a default value set for the mean and sd arguments. First we’ll allow the default mean and sd. rnorm(n = 10) ## [1] -1.46301089 1.69627369 -0.42663047 -0.96478785 -1.73210534 ## [6] -0.35187579 -1.37916099 0.03244959 -0.50626181 0.84396980 The above code drew 10 random draws from a normal distribution with a mean = 0 and an sd = 1 Now let’s set the n = 10, mean = 50, and the sd = 5 to see 10 random draws from a normal distribution with a mean = 50 and an sd = 5 rnorm(n = 10, mean = 50, sd = 5) ## [1] 56.67012 54.10484 37.05729 49.65553 45.12735 53.59119 48.70227 ## [8] 48.75931 54.26585 49.82072 What happens if we do not specify n? Uncomment the code below (remove the #) to see what happens # rnorm(mean = 50, sd = 5) In the above examples, we have labeled our arguments according to their names in the help menu. If you do not label the arguments, they will be called into the function in the order given in the help menu. # must be in order given by help menu to work as intended rnorm(10, 50, 5) ## [1] 47.87710 52.00571 52.74898 56.00776 49.13443 52.17471 51.54882 ## [8] 64.21880 46.91619 53.37984 #out of order, but works bc the arguments are labeled rnorm(n = 10, sd = 5, mean = 50) ## [1] 56.63432 55.99506 51.20510 45.32170 45.63728 49.84423 44.38412 ## [8] 46.71555 55.93258 42.01574 To improve readability (and accuracy) of your code, we would recommend labeling your arguments. 1.3.1 EXERCISE 2 A. Use the arrow operator to create an object called object2 that stores 100 draws from a normal distribution with mean = 500 and sd = 100. SHOW ANSWER A object2 &lt;- rnorm(n = 100, mean = 500, sd = 100) object2 ## [1] 492.4478 446.4851 504.1019 442.4561 424.4263 467.9074 374.5892 ## [8] 315.5951 476.1336 551.6410 604.9400 503.6487 471.7890 648.4251 ## [15] 515.5091 479.0175 496.9319 634.6657 542.1605 511.9253 599.9905 ## [22] 640.5030 455.3552 517.5519 252.5527 423.9946 545.4930 501.1837 ## [29] 298.7872 438.0874 278.4709 480.4669 506.1366 676.6876 466.8874 ## [36] 493.5519 509.7616 526.4062 402.9924 584.9117 462.8711 562.8592 ## [43] 444.8662 654.7531 331.3296 517.3705 317.1185 523.5117 524.8021 ## [50] 387.6405 574.9920 266.3833 579.4772 363.5422 664.6194 464.3207 ## [57] 574.2931 392.9838 547.1084 578.8906 539.7863 563.7042 537.5788 ## [64] 482.7515 422.3333 369.1405 617.4430 561.8223 613.5657 495.6875 ## [71] 561.2924 614.0253 443.5391 716.1883 563.4372 457.8576 705.7320 ## [78] 551.9105 521.5673 514.1611 481.2698 519.2805 650.9915 342.6809 ## [85] 575.8271 402.2799 536.6852 646.1728 270.8476 409.0363 406.2993 ## [92] 545.4601 558.2834 493.0857 525.7903 562.3269 489.5516 353.6746 ## [99] 522.2331 379.8273 B. Call hist(object2) to create a histogram of your normal distribution SHOW ANSWER B hist(object2) Look at the environment. What does it tell you about object2? The environment pane provides details about objects. We can see that object2 is a numeric object with items 1 through 100. Then we can see the first few numeric items in the object. Let’s create some more R objects that are collections of several values. To accomplish this, we will use the function c(), which stands for concatenate or combine. Usually functions are named with a full word describing what they do but because combining items together is so common, this function gets a very short name. object3 &lt;- c(55, 60, 35, 70) Check out the environment now. It worked! We created object3 Let’s create another object containing a different type of data object4 &lt;- c(&quot;Jack&quot;, &quot;Leila&quot;, &quot;Rohit&quot;) Check out the environment now. Notice that it specifies that object4 is a character (chr) vector 1.4 More Functions Let’s sum() everything in object3 sum(object3) ## [1] 220 Try the mean() function on object3 mean(object3) ## [1] 55 What happens if we try to sum() object4? Uncomment the code below to try it #sum(object4) What if we take the square root of object3? The sum() and mean() functions both take a vector and return one number. What about sqrt() where we want multiple answers given multiple inputs? sqrt(object3) ## [1] 7.416198 7.745967 5.916080 8.366600 It worked! Most functions in R are vectorized meaning that they will work on a vector as well as a single value. This means that in R, we usually do not need to write loops like we would in other languages. 1.4.1 EXERCISE 3 Try the following functions on object3 and on object4. What do each of the below functions do? Optionally, call up the help menu for these functions to learn more. A. class() B. length() C. summary() D. str() SHOW ANSWER The class() function provides information about the type of object class(object3) ## [1] &quot;numeric&quot; class(object4) ## [1] &quot;character&quot; length() tells us how many items are in each vector length(object3) ## [1] 4 length(object4) ## [1] 3 summary() provides a summary of an object. In the case of object3, we have a 6 number numeric summary describing the minimum, 1st quartile, median, mean, 3rd quartile, and maximum. For object 4, summary() tells us that the object is a character summary(object3) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 35.0 50.0 57.5 55.0 62.5 70.0 summary(object4) ## Length Class Mode ## 3 character character Finally, str() provides the structure of an object. For object3 and object4 str() returns the same information that we see in the environment, but for more complex objects, str() can be very helpful str(object3) ## num [1:4] 55 60 35 70 str(object4) ## chr [1:3] &quot;Jack&quot; &quot;Leila&quot; &quot;Rohit&quot; 1.5 DataFrames Let’s move on to learning about dataframes. There are lots of different basic data structures in R. Besides the dataframe, there are also arrays, lists, matrices, etc. We are going to skip those in favor of spending time learning the data structure you’ll probably use most – the dataframe. We use dataframes to store heterogeneous tabular data in R: tabular, meaning that individuals or observations are typically represented in rows, while variables or features are represented in columns; heterogeneous, meaning that columns/features/variables can be different classes (a variable like age, can be numeric, while another, like cause of death, can be a character string). 1.6 R Packages We have the gapminder.csv file into our project directory, but we don’t know anything about it yet. Our goal will be to read it into R so we can start exploring it. There are lots of ways to load data into R. There is a point-and-click RStudio menu and go to File &gt; Import Data Set &gt; Import From Text File but that is not the most reproducible way to read in data. Instead, we would prefer that you read data into R for analysis as part of your script. I gave you the gm dataset as a csv file. “csv” stands for comma separated values. You can save any Excel, SPSS, Qualtrics, etc. data file as a .csv and then import it into R. This is the workflow that we would recommend. To read a csv file into R, we are going to use a function read_csv() that is accessed from a package. You can think of an R package like an app on your phone. Fist, we will need to install it from the internet. When we call the install.packages() function, R goes to the Comprehensive R Archive Network (CRAN) and downloads the specified package. There are over 10K packages listed on CRAN, over 1500 on Bioconductor (bioinformatics packages), and many more under development on people’s github pages etc. You can be sure a package is safe to download if it comes from the CRAN or from Bioconductor. Uncomment the line below to run the install.packages() function # install.packages(&quot;tidyverse&quot;) Once we have installed it to this computer, you will not need to do that again (until you update R or your OS, etc). Therefore, comment out the install line. The library() command loads the functions from that package into the R environment so that we can use them. This is like opening the app. We will need to do this every time we open the script. library(tidyverse) ## ── Attaching packages ───────────────── tidyverse 1.2.1 ── ## ✔ ggplot2 3.2.0 ✔ purrr 0.3.2 ## ✔ tibble 2.1.3 ✔ dplyr 0.8.3 ## ✔ tidyr 0.8.3 ✔ stringr 1.4.0 ## ✔ readr 1.3.1 ✔ forcats 0.4.0 ## ── Conflicts ──────────────────── tidyverse_conflicts() ── ## ✖ dplyr::filter() masks stats::filter() ## ✖ dplyr::lag() masks stats::lag() We can see based on the output from the library(tidyverse) line that the tidyverse is actually a megapackage, containing 8 packages. All of these packages share a similar syntax in an attempt to simplify coding and readability for R users. Aside from the core tidyverse packages, there are around 10 other packages Ok! Now let’s write the line of code to read the csv file into R. We will use the read_csv() function that comes from the readr package (one of the tidyverse packages). At the beginning of the session, we asked you to save the gm file into the data directory of your project file, so when we write the path to the gm file, we’ll specify that it is in the data folder. gm &lt;- read_csv(&quot;data/gapminder.csv&quot;) ## Parsed with column specification: ## cols( ## country = col_character(), ## continent = col_character(), ## year = col_double(), ## lifeExp = col_double(), ## pop = col_double(), ## gdpPercap = col_double() ## ) If the above line did not work for you, follow the steps to create an R project with the gm file in a subdirectory called data. Assuming you were able to load the data, let’s move on! Let’s look at this object by calling its name gm ## # A tibble: 1,704 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. ## 7 Afghanistan Asia 1982 39.9 12881816 978. ## 8 Afghanistan Asia 1987 40.8 13867957 852. ## 9 Afghanistan Asia 1992 41.7 16317921 649. ## 10 Afghanistan Asia 1997 41.8 22227415 635. ## # … with 1,694 more rows Because we read in the data using read_csv(), the dataframe was read in as a modified dataframe called a tibble. Printing tibbles to the console looks great, but that used to not be the case. If you’d like to learn more about the difference between dataframes and tibbles please see the tibbles section of R for Data Science Let’s also use the View() function to look at the data. Note that this is a read only viewer - not like Excel where you can go in and change cell values etc. This feature helps with reproducibility. View(gm) Let’s go back to the script. Your script is still there. It is in a tab next to the viewer tab. The third way to look at a dataframe or tibble is to click on the blue arrow next to the gm name in the Environment. {width = 400px} This view enables you to see the variable names and classes while you type code, so this is often what my environment looks like. 1.7 Inspecting Dataframes There are several functions that are useful for investigating dataframes. We already saw some of them in the section on Functions above. Instead of printing the whole dataframe to the console, we can print an abbreviated version using head() and tail(). By default, these functions give us the first and last 6 rows respectively head(gm) ## # A tibble: 6 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. tail(gm) ## # A tibble: 6 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Zimbabwe Africa 1982 60.4 7636524 789. ## 2 Zimbabwe Africa 1987 62.4 9216418 706. ## 3 Zimbabwe Africa 1992 60.4 10704340 693. ## 4 Zimbabwe Africa 1997 46.8 11404948 792. ## 5 Zimbabwe Africa 2002 40.0 11926563 672. ## 6 Zimbabwe Africa 2007 43.5 12311143 470. # see the first 12 rows using the n = argument head(gm, n = 12) ## # A tibble: 12 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. ## 7 Afghanistan Asia 1982 39.9 12881816 978. ## 8 Afghanistan Asia 1987 40.8 13867957 852. ## 9 Afghanistan Asia 1992 41.7 16317921 649. ## 10 Afghanistan Asia 1997 41.8 22227415 635. ## 11 Afghanistan Asia 2002 42.1 25268405 727. ## 12 Afghanistan Asia 2007 43.8 31889923 975. Remember, class() tells us the type of object class(gm) ## [1] &quot;spec_tbl_df&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; We can see that gm is a dataframe and a tibble (tbl) We can look at the number of rows and columns with dim(), just the number of rows with nrow() and just the number of columns with ncol() dim(gm) ## [1] 1704 6 nrow(gm) ## [1] 1704 ncol(gm) ## [1] 6 names() will show us the column names names(gm) ## [1] &quot;country&quot; &quot;continent&quot; &quot;year&quot; &quot;lifeExp&quot; &quot;pop&quot; &quot;gdpPercap&quot; And probably the two you’ll use the most to inspect data frames, because they are the most descriptive, are summary() and str(). Let’s start with summary() summary(gm) ## country continent year lifeExp ## Length:1704 Length:1704 Min. :1952 Min. :23.60 ## Class :character Class :character 1st Qu.:1966 1st Qu.:48.20 ## Mode :character Mode :character Median :1980 Median :60.71 ## Mean :1980 Mean :59.47 ## 3rd Qu.:1993 3rd Qu.:70.85 ## Max. :2007 Max. :82.60 ## pop gdpPercap ## Min. :6.001e+04 Min. : 241.2 ## 1st Qu.:2.794e+06 1st Qu.: 1202.1 ## Median :7.024e+06 Median : 3531.8 ## Mean :2.960e+07 Mean : 7215.3 ## 3rd Qu.:1.959e+07 3rd Qu.: 9325.5 ## Max. :1.319e+09 Max. :113523.1 Notice that the output depends on the type of column. For country, a character vector, we get a frequency count of the number of occurences of the first few countries. Same for continent. The other columns are numeric, so their summary is a six number summary showing the minimum, 1st quartile, median, mean, 3rd quartile, and the maximum. The read_csv() determined what type of column each one was while we were reading in the data. Of course, there are arguments to change the type of column within the read_csv() function. Let’s look now at the structure of gm. str(gm) ## Classes &#39;spec_tbl_df&#39;, &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;: 1704 obs. of 6 variables: ## $ country : chr &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; ... ## $ continent: chr &quot;Asia&quot; &quot;Asia&quot; &quot;Asia&quot; &quot;Asia&quot; ... ## $ year : num 1952 1957 1962 1967 1972 ... ## $ lifeExp : num 28.8 30.3 32 34 36.1 ... ## $ pop : num 8425333 9240934 10267083 11537966 13079460 ... ## $ gdpPercap: num 779 821 853 836 740 ... ## - attr(*, &quot;spec&quot;)= ## .. cols( ## .. country = col_character(), ## .. continent = col_character(), ## .. year = col_double(), ## .. lifeExp = col_double(), ## .. pop = col_double(), ## .. gdpPercap = col_double() ## .. ) The structure tells us that gm is a dataframe and tibble object and it specifies the dimensions. Below that, it also gives us each of the column names with the type of data it contains and the first 4 or 5 values for each column. 1.8 Accessing variables Notice in the str() output that there is a $ in front of each of the variable names. That symbol is how we access invidual variables / columns / vectors from a dataframe object To access a variable from a dataframe, the syntax we want is dataframe$columnname Let’s use this to print out all of values in the pop variable. First we call the dataframe, then $ and the variable name gm$pop Whoa. That function calls the whole column, which is 1704 observations long. Usually printing out a long vector or column to the console is not useful. Maybe we meant to call head() on one column head(gm$pop) ## [1] 8425333 9240934 10267083 11537966 13079460 14880372 What if we want to see the first 20 country values? head(gm$country, n = 20) ## [1] &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; ## [6] &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Afghanistan&quot; ## [11] &quot;Afghanistan&quot; &quot;Afghanistan&quot; &quot;Albania&quot; &quot;Albania&quot; &quot;Albania&quot; ## [16] &quot;Albania&quot; &quot;Albania&quot; &quot;Albania&quot; &quot;Albania&quot; &quot;Albania&quot; Nice! We can also use the $ to create a new variable and attach it onto our dataframe. First let’s look at the first 20 values of the pop column head(gm$pop, n = 20) ## [1] 8425333 9240934 10267083 11537966 13079460 14880372 12881816 ## [8] 13867957 16317921 22227415 25268405 31889923 1282697 1476505 ## [15] 1728137 1984060 2263554 2509048 2780097 3075321 Let’s say I would like a column where the population is in millions. We’ll take the original gm$pop and divide by 1e6 then save it as a new column on the dataframe. # dataframe$newvar &lt;- dataframe$oldvar / 1e6 gm$popmill &lt;- gm$pop / 1e6 #head of the new column head(gm$popmill) ## [1] 8.425333 9.240934 10.267083 11.537966 13.079460 14.880372 Great! Using this $ syntax, let’s calculate some descriptive statistics for life expectancy in the gm dataset. Notice that the lifeExp variable is mixed case, so be careful in spelling. However, RStudio’s autocomplete function can help. Once you type the gm$ RStudio autocompletes with the options for variable names so you can just select from the list. mean(gm$lifeExp) ## [1] 59.47444 sd(gm$lifeExp) ## [1] 12.91711 range(gm$lifeExp) ## [1] 23.599 82.603 1.8.1 EXERCISE 4 A. What’s the standard deviation of the population variable (hint: get help on the sd function with ?sd) B. What’s the mean gdpPercap? C. What’s the range of years represented in the data? D. Run a summary on the lifeExp column SHOW ANSWERS sd(gm$pop) ## [1] 106157897 mean(gm$gdpPercap) ## [1] 7215.327 range(gm$year) ## [1] 1952 2007 summary(gm$lifeExp) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 23.60 48.20 60.71 59.47 70.85 82.60 While the gm dataset is fully complete (no missing values), in real life, dataframes often come with missing values. For basic statistical functions like mean, sd, etc., there is an argument na.rm that we can use to remove missing values prior to calculating the statistic. In this case, the result will not change because we do not have any missings, but in case your dataset does, here is what the code would look like # calculate the mean population mean(gm$pop) ## [1] 29601212 #calculate the mean population after removing missings mean(gm$pop, na.rm = TRUE) ## [1] 29601212 1.9 Subset a dataframe using filter() Often we want to look at just a subset of the data that meet certain criteria. One really nice way to do this is the filter() function from the dplyr package. The dplyr package is one that we loaded when we loaded the tidyverse. filter() subsets rows of a dataframe. The first argument to filter() is the dataframe we are filtering from and the second argument is the logical condition(s) the row must meet to be returned There are six basic logical operators in R -equal to == -not equal to != -greather than &gt; -greater than or equal to &gt;= -less than &lt; -less than or equal to &lt;= You can chain multiple conditions together with the AND operator &amp; or the OR | operator Let’s see how it works by filtering for rows where the population is over 70Million. The first argument is the dataframe and the second is the logical criteria a row must meet to be returned. I’ll choose to use my new popmill variable filter(gm, popmill &gt; 70) ## # A tibble: 118 x 7 ## country continent year lifeExp pop gdpPercap popmill ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Bangladesh Asia 1972 45.3 70759295 630. 70.8 ## 2 Bangladesh Asia 1977 46.9 80428306 660. 80.4 ## 3 Bangladesh Asia 1982 50.0 93074406 677. 93.1 ## 4 Bangladesh Asia 1987 52.8 103764241 752. 104. ## 5 Bangladesh Asia 1992 56.0 113704579 838. 114. ## 6 Bangladesh Asia 1997 59.4 123315288 973. 123. ## 7 Bangladesh Asia 2002 62.0 135656790 1136. 136. ## 8 Bangladesh Asia 2007 64.1 150448339 1391. 150. ## 9 Brazil Americas 1962 55.7 76039390 3337. 76.0 ## 10 Brazil Americas 1967 57.6 88049823 3430. 88.0 ## # … with 108 more rows We do not need to specify gm$popmill because the first argument told R we would be operating within the gm dataframe. Therefore, we need only specify the variable name in the second argument. 118 rows meet this criteria. Now let’s see rows belonging to the United States. First let’s use View() to see how USA is spelled. Click on the country column header to sort by country to quickly scroll to the U section. View(gm) Ok, now that we know how it is spelled, we can write a line of code to filter for where country is ‘United States’. We need the quotes because country is a character (factor) variable. filter(gm, country == &#39;United States&#39;) ## # A tibble: 12 x 7 ## country continent year lifeExp pop gdpPercap popmill ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 United States Americas 1952 68.4 157553000 13990. 158. ## 2 United States Americas 1957 69.5 171984000 14847. 172. ## 3 United States Americas 1962 70.2 186538000 16173. 187. ## 4 United States Americas 1967 70.8 198712000 19530. 199. ## 5 United States Americas 1972 71.3 209896000 21806. 210. ## 6 United States Americas 1977 73.4 220239000 24073. 220. ## 7 United States Americas 1982 74.6 232187835 25010. 232. ## 8 United States Americas 1987 75.0 242803533 29884. 243. ## 9 United States Americas 1992 76.1 256894189 32004. 257. ## 10 United States Americas 1997 76.8 272911760 35767. 273. ## 11 United States Americas 2002 77.3 287675526 39097. 288. ## 12 United States Americas 2007 78.2 301139947 42952. 301. Now let’s return the data that meets multiple criteria at once. We’ll use the &amp; to combine the year == 1982 and country == “United States” criteria filter(gm, year == 1982 &amp; country == &#39;United States&#39;) ## # A tibble: 1 x 7 ## country continent year lifeExp pop gdpPercap popmill ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 United States Americas 1982 74.6 232187835 25010. 232. We’ll do one more together before you will practice on your own. Let’s filter the gm dataset for rows where the population is higher than 1 billion (1e9). This time, let’s start with the original pop variable filter(gm, pop &gt; 1e9) ## # A tibble: 8 x 7 ## country continent year lifeExp pop gdpPercap popmill ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 China Asia 1982 65.5 1000281000 962. 1000. ## 2 China Asia 1987 67.3 1084035000 1379. 1084. ## 3 China Asia 1992 68.7 1164970000 1656. 1165. ## 4 China Asia 1997 70.4 1230075000 2289. 1230. ## 5 China Asia 2002 72.0 1280400000 3119. 1280. ## 6 China Asia 2007 73.0 1318683096 4959. 1319. ## 7 India Asia 2002 62.9 1034172547 1747. 1034. ## 8 India Asia 2007 64.7 1110396331 2452. 1110. 1.9.1 EXERCISE 1.5 Use the filter() function to return rows matching the given criteria. A. Which rows have life expectancies of more than 80 years (&gt;80)? SHOW ANSWER A filter(gm, lifeExp &gt; 80) ## # A tibble: 21 x 7 ## country continent year lifeExp pop gdpPercap popmill ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Australia Oceania 2002 80.4 19546792 30688. 19.5 ## 2 Australia Oceania 2007 81.2 20434176 34435. 20.4 ## 3 Canada Americas 2007 80.7 33390141 36319. 33.4 ## 4 France Europe 2007 80.7 61083916 30470. 61.1 ## 5 Hong Kong, China Asia 2002 81.5 6762476 30209. 6.76 ## 6 Hong Kong, China Asia 2007 82.2 6980412 39725. 6.98 ## 7 Iceland Europe 2002 80.5 288030 31163. 0.288 ## 8 Iceland Europe 2007 81.8 301931 36181. 0.302 ## 9 Israel Asia 2007 80.7 6426679 25523. 6.43 ## 10 Italy Europe 2002 80.2 57926999 27968. 57.9 ## # … with 11 more rows B. Which countries had a low GDP per capita (&lt; 500) in 2007? SHOW ANSWER B filter(gm, gdpPercap &lt; 500 &amp; year == 2007) ## # A tibble: 4 x 7 ## country continent year lifeExp pop gdpPercap popmill ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Burundi Africa 2007 49.6 8390505 430. 8.39 ## 2 Congo, Dem. Rep. Africa 2007 46.5 64606759 278. 64.6 ## 3 Liberia Africa 2007 45.7 3193942 415. 3.19 ## 4 Zimbabwe Africa 2007 43.5 12311143 470. 12.3 filter(gm, year == 2007 &amp; gdpPercap &lt; 500) ## # A tibble: 4 x 7 ## country continent year lifeExp pop gdpPercap popmill ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Burundi Africa 2007 49.6 8390505 430. 8.39 ## 2 Congo, Dem. Rep. Africa 2007 46.5 64606759 278. 64.6 ## 3 Liberia Africa 2007 45.7 3193942 415. 3.19 ## 4 Zimbabwe Africa 2007 43.5 12311143 470. 12.3 # order doesn&#39;t matter C. Which rows have extremely low GDP per capita (&lt; 300) OR extremely low life expectancy (&lt; 30)? SHOW ANSWER C filter(gm, gdpPercap &lt; 300 | lifeExp &lt; 30) ## # A tibble: 6 x 7 ## country continent year lifeExp pop gdpPercap popmill ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. 8.43 ## 2 Congo, Dem. Rep. Africa 2002 45.0 55379852 241. 55.4 ## 3 Congo, Dem. Rep. Africa 2007 46.5 64606759 278. 64.6 ## 4 Guinea-Bissau Africa 1952 32.5 580653 300. 0.581 ## 5 Lesotho Africa 1952 42.1 748747 299. 0.749 ## 6 Rwanda Africa 1992 23.6 7290203 737. 7.29 1.10 Plots in base R Plots are a great way to help us explore our dataset to see relationships, investigate interactions, diagnose problems, etc. Here we will introduce plotting using base R (without loading any extra packages). Chapter 2 is all about plotting using the premier plotting package in R, ggplot2. Jump to /@ref(ggplot) Let’s start out with a histogram of the life expectancy variable from gm. hist(gm$lifeExp) R decided how many breaks to insert in the above histogram, but we can set that manually using the breaks = argument. hist(gm$lifeExp, breaks=100) We can also change the color of the bars using col =. hist(gm$lifeExp, breaks=100, col=&#39;blue&#39;) If we wanted to look at more than one numeric variable we could try a scatterplot. The syntax for plot(dataframe$varX, dataframe$varY) plot(gm$gdpPercap, gm$lifeExp) The default plotting character in base R is an open circle, which I dislike. Let’s change that using the pch = argument, which stands for plotting character. pch ranges from 0 - 25 and you can easily search for what each looks like on the internet. I’ll change mine to pch = 16, a filled-in circle. plot(gm$gdpPercap, gm$lifeExp, pch = 16) Next, I would like to change the color of the points to red using col = &quot;red&quot; plot(gm$gdpPercap, gm$lifeExp, pch = 16, col = &quot;red&quot;) You can see the names of all 657 base R colors colors() To add a title, the argument is main = plot(gm$gdpPercap, gm$lifeExp, pch = 16, col = &quot;red&quot;, main = &quot;Life Exp vs GDP&quot;) Finally, we’ll add an xlabel and a ylabel both in quotes. plot(gm$gdpPercap, gm$lifeExp, pch = 16, col = &quot;red&quot;, main = &quot;Life Exp vs GDP&quot;, ylab = &quot;Life Expectancy (years)&quot;, xlab = &quot;Per-capita GDP ($)&quot;) There are hundreds of plotting parameters you can use to customize your plot’s appearance. I know these parameters because I have learned them. The internet is your friend in this case, so if you forget how to modify a parameter, don’t be afraid to Google it. 1.10.1 EXERCISE 5 Create a histogram to show the distribution of the gdpPercap variable with 100 breaks. Optional: Add color, axis labels, and a title SHOW ANSWER hist(gm$gdpPercap, breaks = 100) Visualizations are a large part of R’s appeal and in our opinion, learning to plot using ggplot2 will serve you well. Therefore, we only cover the very basics of plotting using base R here, and devote more time to a more comprehensive dive into ggplot2 in Chapter 2 /@ref(ggplot2) 1.11 Write csv file We’ve already seen how to read in data using read_csv(). Now we’ll do the opposite. There are going to be some cases when you need to save the data you’re working on to open up outside of R. Just like R has functions to read data of many different kinds of formats, it also has functions to write data into many different kinds of formats. We’ll stick to csv format here. First, let’s create a dataframe that is a subset of gm where the year is 1997. We’ll name the resulting dataframe gm97 &lt;- filter(gm, year == 1997) To save this as a csv file, we will call write_csv() where the first argument is the R object to be written and the second argurment is the name of the proposed file. write_csv(gm97, &quot;gm97.csv&quot;) Where did it go? Let’s have a look at the Files pane (bottom right) and there it is. It went into our working directory (project directory) automatically. We don’t need to worry about our working directory here because we’re using an R project. 1.12 Saving your work and quitting R We’ll close this chapter with how to save your work. Our suggestion is to make sure your R script (top left) is saved and then throw out the rest. After all, the script created the objects in the environment, the output in the console, and all the plots. Remember that to save your script, go to File –&gt; Save or CMD + S (mac) and CTRL + S (pc). I prefer that RStudio never ask me to save my workspace (Environment, Plots, etc) so I have set that preference in Tools –&gt; Global Options –&gt; General. Save workspace to .RData on exit = “never”. While you are at it, uncheck the options for 1. Restore most recently opened project 2.Restore previosuly open source documents on startup 3. Restore .RData into workspace at startup Once your script is saved, quit RStudio. To re-open the project and prove to yourself that all of your hard work has been preserved, double click the Rproj file to launch RStudio in your project directory. Now open your script and start running your code. To run all the code in an R file (there have to be no errors), highlight the entire code CMD + A (mac) or CTRL + A (pc) and then run. Woohooo! Happy Running! See you in Chapter 2. Credit to Modern Dive for the R and RStudio analogies↩ "],
["ggplot.html", "Chapter 2 Data Visualization with ggplot2 2.1 Resources to learn ggplot2 2.2 Make sure everyone has tidyverse or readr, dplyr, ggplot2 2.3 Download data and make a new project 2.4 About ggplot2 2.5 Plotting bivariate data: continuous Y by continuous X 2.6 Plotting bivariate data: continuous Y by categorical X 2.7 Plotting univariate continuous data 2.8 Publication-ready plots &amp; themes", " Chapter 2 Data Visualization with ggplot2 This section will cover fundamental concepts for creating effective data visualization and will introduce tools and techniques for visualizing large, high-dimensional data using R. We will review fundamental concepts for visually displaying quantitative information, such as using series of small multiples, avoiding “chart-junk,” and maximizing the data-ink ratio. We will cover the grammar of graphics (geoms, aesthetics, stats, and faceting), and using the ggplot2 package to create plots layer-by-layer. 2.1 Resources to learn ggplot2 Chapter 3 in R 4 Data Science R Graphics Cookbook *Show the Help menu cheat sheet This lesson assumes a basic familiarity with R and manipulating data with dplyr and %&gt;%. 2.2 Make sure everyone has tidyverse or readr, dplyr, ggplot2 2.3 Download data and make a new project 2.3.1 Gapminder data We’re going to work with a cleaned-up excerpt from the Gapminder data. Download the gapminder.csv data by clicking here or using the link above. Let’s read in the data to an object called gm and take a look with View. Remember, we need to load both the dplyr and readr packages for efficiently reading in and displaying this data. # Load packages library(readr) library(dplyr) # Read in downloaded usind readr package gm &lt;- read_csv(file=&quot;data/gapminder.csv&quot;) # Show the first few lines of the data gm ## # A tibble: 1,704 x 6 ## country continent year lifeExp pop gdpPercap ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Afghanistan Asia 1952 28.8 8425333 779. ## 2 Afghanistan Asia 1957 30.3 9240934 821. ## 3 Afghanistan Asia 1962 32.0 10267083 853. ## 4 Afghanistan Asia 1967 34.0 11537966 836. ## 5 Afghanistan Asia 1972 36.1 13079460 740. ## 6 Afghanistan Asia 1977 38.4 14880372 786. ## 7 Afghanistan Asia 1982 39.9 12881816 978. ## 8 Afghanistan Asia 1987 40.8 13867957 852. ## 9 Afghanistan Asia 1992 41.7 16317921 649. ## 10 Afghanistan Asia 1997 41.8 22227415 635. ## # … with 1,694 more rows # Optionally bring up data in a viewer window. # View(gm) This particular excerpt has 1704 observations on six variables: country a categorical variable 142 levels continent, a categorical variable with 5 levels year: going from 1952 to 2007 in increments of 5 years pop: population gdpPercap: GDP per capita lifeExp: life expectancy 2.3.2 dplyr review The dplyr package gives you a handful of useful verbs for managing data. On their own they don’t do anything that base R can’t do. Here are some of the single-table verbs we’ll be working with in this lesson (single-table meaning that they only work on a single table – contrast that to two-table verbs used for joining data together). They all take a data.frame or tbl as their input for the first argument, and they all return a data.frame or tbl as output. filter(): filters rows of the data where some condition is true select(): selects out particular columns of interest mutate(): adds new columns or changes values of existing columns arrange(): arranges a data frame by the value of a column summarize(): summarizes multiple values to a single value, most useful when combined with… group_by(): groups a data frame by one or more variable. Most data operations are useful done on groups defined by variables in the the dataset. The group_by function takes an existing data frame and converts it into a grouped data frame where summarize() operations are performed by group. Additionally, the %&gt;% operator allows you to “chain” operations together. Rather than nesting functions inside out, the %&gt;% operator allows you to write operations left-to-right, top-to-bottom. Let’s say we wanted to get the average life expectancy and GDP (not GDP per capita) for Asian countries for each year. The %&gt;% would allow us to do this: gm %&gt;% mutate(gdp=gdpPercap*pop) %&gt;% filter(continent==&quot;Asia&quot;) %&gt;% group_by(year) %&gt;% summarize(mean(lifeExp), mean(gdp)) ## # A tibble: 12 x 3 ## year `mean(lifeExp)` `mean(gdp)` ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1952 46.3 34095762661. ## 2 1957 49.3 47267432088. ## 3 1962 51.6 60136869012. ## 4 1967 54.7 84648519224. ## 5 1972 57.3 124385747313. ## 6 1977 59.6 159802590186. ## 7 1982 62.6 194429049919. ## 8 1987 64.9 241784763369. ## 9 1992 66.5 307100497486. ## 10 1997 68.0 387597655323. ## 11 2002 69.2 458042336179. ## 12 2007 70.7 627513635079. Instead of this: summarize( group_by( filter( mutate(gm, gdp=gdpPercap*pop), continent==&quot;Asia&quot;), year), mean(lifeExp), mean(gdp)) 2.4 About ggplot2 ggplot2 is a widely used R package that extends R’s visualization capabilities. It takes the hassle out of things like creating legends, mapping other variables to scales like color, or faceting plots into small multiples. We’ll learn about what all these things mean shortly. Where does the “gg” in ggplot2 come from? The ggplot2 package provides an R implementation of Leland Wilkinson’s Grammar of Graphics (1999). The Grammar of Graphics allows you to think beyond the garden variety plot types (e.g. scatterplot, barplot) and the consider the components that make up a plot or graphic, such as how data are represented on the plot (as lines, points, etc.), how variables are mapped to coordinates or plotting shape or color, what transformation or statistical summary is required, and so on. Specifically, ggplot2 allows you to build a plot layer-by-layer by specifying: a geom, which specifies how the data are represented on the plot (points, lines, bars, etc.), aesthetics that map variables in the data to axes on the plot or to plotting size, shape, color, etc., a stat, a statistical transformation or summary of the data applied prior to plotting, facets, which we’ve already seen above, that allow the data to be divided into chunks on the basis of other categorical or continuous variables and the same plot drawn for each chunk. First, a note about qplot(). The qplot() function is a quick and dirty way of making ggplot2 plots. You might see it if you look for help with ggplot2, and it’s even covered extensively in the ggplot2 book. And if you’re used to making plots with built-in base graphics, the qplot() function will probably feel more familiar. But the sooner you abandon the qplot() syntax the sooner you’ll start to really understand ggplot2’s approach to building up plots layer by layer. So we’re not going to use it at all in this class. See R Graphics Cookbook for more help with ggplot2. 2.5 Plotting bivariate data: continuous Y by continuous X The ggplot function has two required arguments: the data used for creating the plot, and an aesthetic mapping to describe how variables in said data are mapped to things we can see on the plot. First let’s load the package: library(ggplot2) Now, let’s lay out the plot. If we want to plot a continuous Y variable by a continuous X variable we’re probably most interested in a scatter plot. Here, we’re telling ggplot that we want to use the gm dataset, and the aesthetic mapping will map gdpPercap onto the x-axis and lifeExp onto the y-axis. Remember that the variable names are case sensitive! ggplot(gm, aes(x = gdpPercap, y = lifeExp)) When we do that we get a blank canvas with no data showing (you might get an error if you’re using an old version of ggplot2). That’s because all we’ve done is laid out a two-dimensional plot specifying what goes on the x and y axes, but we haven’t told it what kind of geometric object to plot. The obvious choice here is a point. Check out docs.ggplot2.org to see what kind of geoms are available. ggplot(gm, aes(x = gdpPercap, y = lifeExp)) + geom_point() Here, we’ve built our plot in layers. First, we create a canvas for plotting layers to come using the ggplot function, specifying which data to use (here, the gm data frame), and an aesthetic mapping of gdpPercap to the x-axis and lifeExp to the y-axis. We next add a layer to the plot, specifying a geom, or a way of visually representing the aesthetic mapping. Now, the typical workflow for building up a ggplot2 plot is to first construct the figure and save that to a variable (for example, p), and as you’re experimenting, you can continue to re-define the p object as you develop “keeper commands”. First, let’s construct the graphic. Notice that we don’t have to specify x= and y= if we specify the arguments in the correct order (x is first, y is second). p &lt;- ggplot(gm, aes(gdpPercap, lifeExp)) p The p object now contains the canvas, but nothing else. Try displaying it by just running p. Let’s experiment with adding points and a different scale to the x-axis. # Experiment with adding points p + geom_point() # Experiment with a different scale p + geom_point() + scale_x_log10() I like the look of using a log scale for the x-axis. Let’s make that stick. p &lt;- p + scale_x_log10() p Now, if we re-ran p still nothing would show up because the p object just contains a blank canvas. Now, re-plot again with a layer of points: p + geom_point() Now notice what I’ve saved to p at this point: only the basic plot layout and the log10 mapping on the x-axis. I didn’t save any layers yet because I want to fiddle around with the points for a bit first. Above we implied the aesthetic mappings for the x- and y- axis should be gdpPercap and lifeExp, but we can also add aesthetic mappings to the geoms themselves. For instance, what if we wanted to color the points by the value of another variable in the dataset, say, continent? p + geom_point(aes(color=continent)) Notice the difference here. If I wanted the colors to be some static value, I wouldn’t wrap that in a call to aes(). I would just specify it outright. Same thing with other features of the points. For example, lets make all the points huge (size=8) blue (color=&quot;blue&quot;) semitransparent (alpha=(1/4)) triangles (pch=17): p + geom_point(color=&quot;blue&quot;, pch=17, size=8, alpha=1/4) Now, this time, let’s map the aesthetics of the point character to certain features of the data. For instance, let’s give the points different colors and character shapes according to the continent, and map the size of the point onto the life Expectancy: p + geom_point(aes(col=continent, shape=continent, size=lifeExp)) Now, this isn’t a great plot because there are several aesthetic mappings that are redundant. Life expectancy is mapped to both the y-axis and the size of the points – the size mapping is superfluous. Similarly, continent is mapped to both the color and the point character (the shape is superfluous). Let’s get rid of that, but let’s make the points a little bigger outside of an aesthetic mapping. p + geom_point(aes(col=continent), size=1.5) EXERCISE 1 Re-create this same plot from scratch without saving anything to a variable. That is, start from the ggplot call. Start with the ggplot() function. Use the gm data. Map gdpPercap to the x-axis and lifeExp to the y-axis. Add points to the plot Make the points size 3 Map continent onto the aesthetics of the point Use a log10 scale for the x-axis. 2.5.1 Adding layers Let’s add a fitted curve to the points. Recreate the plot in the p object if you need to. p &lt;- ggplot(gm, aes(gdpPercap, lifeExp)) + scale_x_log10() p + geom_point() + geom_smooth() By default geom_smooth() will try to lowess (Locally Weighted Scatterplot Smoothing) for data with n&lt;1000 or GAM (Generalized Additive models) for data with n&gt;1000. (In the geom_smooth help menu you can read all about these) geom_smooth() using method = ‘gam’ and formula ‘y ~ s(x, bs = “cs”)’. The s = smoothing function. bs = basis of smoothing and cs = cubic regression spines with shrinkage We can change the geom_smooth() behavior by tweaking the parameters to use a linear model instead of GAM p + geom_point() + geom_smooth(method=&quot;lm&quot;) Now tweak the parameters of the line to show a thick red line with no standard error stripes p + geom_point() + geom_smooth(lwd=2, se=FALSE, method=&quot;lm&quot;, col=&quot;red&quot;) But let’s add back in our aesthetic mapping to the continents. Notice what happens here. We’re mapping continent as an aesthetic mapping to the color of the points only – so geom_smooth() still works only on the entire data. p + geom_point(aes(color = continent)) + geom_smooth() But notice what happens next: if we make the call to aes() outside of the geom_point() and geom_smooth calls, then the continent variable gets mapped as an aesthetic to all the following geoms. So here, we get separate smoothing lines for each continent. p + aes(color = continent) + geom_point() + geom_smooth() Let’s do it again but remove the standard error stripes and make the lines a bit thicker. p + aes(color = continent) + geom_point() + geom_smooth(se=F, lwd=2) 2.5.2 Faceting Facets display subsets of the data in different panels. There are a couple ways to do this, but facet_wrap() tries to sensibly wrap a series of facets into a 2-dimensional grid of small multiples. Just give it a formula specifying which variables to facet by. We can continue adding more layers, such as smoothing. If you have a look at the help for ?facet_wrap() you’ll see that we can control how the wrapping is laid out. p + geom_point() + facet_wrap(~continent) p + geom_point() + geom_smooth() + facet_wrap(~continent, ncol = 1) 2.5.3 Saving plots There are a few ways to save ggplots. The quickest way, that works in an interactive session, is to use the ggsave() function. You give it a file name and by default it saves the last plot that was printed to the screen. p + geom_point() ggsave(file=&quot;myplot.png&quot;) But if you’re running this through a script, the best way to do it is to pass ggsave() the object containing the plot that is meant to be saved. We can also adjust things like the width, height, and resolution. ggsave() also recognizes the name of the file extension and saves the appropriate kind of file. Let’s save a PDF. pfinal &lt;- p + geom_point() + geom_smooth() + facet_wrap(~continent, ncol=1) ggsave(pfinal, file=&quot;myplot.pdf&quot;, width=5, height=15) EXERCISE 2 Make a scatter plot of lifeExp on the y-axis against year on the x. Make a series of small multiples faceting on continent. Add a fitted curve, smooth or lm, with and without facets. Bonus: using geom_line() and an aesthetic mapping country to group=, make a “spaghetti plot”, showing semitransparent lines connected for each country, faceted by continent. Add a smoothed loess curve with a thick (lwd=3) line with no standard error stripe. Reduce the opacity (alpha=) of the individual black lines. Don’t show Oceania countries (that is, filter() the data where continent!=&quot;Oceania&quot; before you plot it). 2.6 Plotting bivariate data: continuous Y by categorical X With the last example we examined the relationship between a continuous Y variable against a continuous X variable. A scatter plot was the obvious kind of data visualization. But what if we wanted to visualize a continuous Y variable against a categorical X variable? We sort of saw what that looked like in the last exercise. year is a continuous variable, but in this dataset, it’s broken up into 5-year segments, so you could almost think of each year as a categorical variable. But a better example would be life expectancy against continent or country. First, let’s set up the basic plot: p &lt;- ggplot(gm, aes(continent, lifeExp)) Then add points: p + geom_point() That’s not terribly useful. There’s a big overplotting problem. We can try to solve with transparency: p + geom_point(alpha=1/4) But that really only gets us so far. What if we spread things out by adding a little bit of horizontal noise (aka “jitter”) to the data. p + geom_jitter() Note that the little bit of horizontal noise that’s added to the jitter is random. If you run that command over and over again, each time it will look slightly different. The idea is to visualize the density at each vertical position, and spreading out the points horizontally allows you to do that. If there were still lots of over-plotting you might think about adding some transparency by setting the alpha= value for the jitter. p + geom_jitter(alpha=1/2) Probably a more common visualization is to show a box plot: p + geom_boxplot() But why not show the summary and the raw data? p + geom_jitter() + geom_boxplot() Notice how in that example we first added the jitter layer then added the boxplot layer. But the boxplot is now superimposed over the jitter layer. Let’s make the jitter layer go on top. Also, go back to just the boxplots. Notice that the outliers are represented as points. But there’s no distinction between the outlier point from the boxplot geom and all the other points from the jitter geom. Let’s change that. Notice the British spelling. p + geom_boxplot(outlier.colour = &quot;red&quot;) + geom_jitter(alpha=1/2) There’s another geom that’s useful here, called a voilin plot. p + geom_violin() p + geom_violin() + geom_jitter(alpha=1/2) Let’s go back to our boxplot for a moment. p + geom_boxplot() This plot would be a lot more effective if the continents were shown in some sort of order other than alphabetical. To do that, we’ll have to go back to our basic build of the plot again and use the reorder function in our original aesthetic mapping. Here, reorder is taking the first variable, which is some categorical variable, and ordering it by the level of the mean of the second variable, which is a continuous variable. It looks like this #reorder continent by lifeExp p &lt;- ggplot(gm, aes(x=reorder(continent, lifeExp), y=lifeExp)) p + geom_boxplot() EXERCISE 3 Make a jittered strip plot of GDP per capita against continent. Make a box plot of GDP per capita against continent. Using a log10 y-axis scale, overlay semitransparent jittered points on top of box plots, where outlying points are colored. BONUS: Try to reorder the continents on the x-axis by GDP per capita. Why isn’t this working as expected? See ?reorder for clues. Reorder was operating on the mean of the raw variable. We need a mean of the log10 transformed gdpPercap 2.7 Plotting univariate continuous data What if we just wanted to visualize distribution of a single continuous variable? A histogram is the usual go-to visualization. Here we only have one aesthetic mapping instead of two. p &lt;- ggplot(gm, aes(lifeExp)) p + geom_histogram() When we do this ggplot lets us know that we’re automatically selecting the width of the bins, and we might want to think about this a little further. p + geom_histogram(bins=30) p + geom_histogram(bins=10) p + geom_histogram(bins=200) p + geom_histogram(bins=60) Alternatively we could plot a smoothed density curve instead of a histogram: p + geom_density() Back to histograms. What if we wanted to color this by continent? p + geom_histogram(aes(color=continent)) That’s not what we had in mind. That’s just the outline of the bars. We want to change the fill color of the bars. p + geom_histogram(aes(fill=continent)) Well, that’s not exactly what we want either. If you look at the help for ?geom_histogram you’ll see that by default it stacks overlapping points. This isn’t really an effective visualization. Let’s change the position argument. p + geom_histogram(aes(fill=continent), position=&quot;identity&quot;) But the problem there is that the histograms are blocking each other. What if we tried transparency? Faceting? p + geom_histogram(aes(fill=continent), position=&quot;identity&quot;, alpha=1/3) That’s somewhat helpful, and might work for two distributions, but it gets cumbersome with 5. Try faceting: p + geom_histogram() + facet_wrap(~continent) Let’s go back and try this with density plots, first changing the color of the line: p + geom_density(aes(color=continent), lwd = 2) Then by changing the color of the fill and setting the transparency to 25%: p + geom_density(aes(fill=continent), alpha=1/4) EXERCISE 4 Plot a histogram of GDP Per Capita. Do the same but use a log10 x-axis. Still on the log10 x-axis scale, try a density plot mapping continent to the fill of each density distribution, and reduce the opacity. Still on the log10 x-axis scale, make a histogram faceted by continent and filled by continent. Facet with a single column (see ?facet_wrap for help). Save this figure to a 6x10 PDF file. 2.8 Publication-ready plots &amp; themes Let’s make a plot we made earlier (life expectancy versus the log of GDP per capita with points colored by continent with lowess smooth curves overlaid without the standard error ribbon): p &lt;- ggplot(gm, aes(gdpPercap, lifeExp)) p &lt;- p + scale_x_log10() p &lt;- p + aes(col=continent) + geom_point() + geom_smooth(lwd=2, se=FALSE) Give the plot a title and axis labels: p &lt;- p + ggtitle(&quot;Life expectancy vs GDP by Continent&quot;) p &lt;- p + xlab(&quot;GDP Per Capita (USD)&quot;) + ylab(&quot;Life Expectancy (years)&quot;) By default, the “gray” theme is the usual background (I’ve changed this course website to use the black and white background for all images). p + theme_gray() We could also get a black and white background: p + theme_bw() Or go a step further and remove the gridlines: p + theme_classic() Finally, there’s another package that gives us lots of different themes. Install it if you don’t have it already. Install all its dependencies along with it. install.packages(&quot;ggthemes&quot;, dependencies = TRUE) library(ggthemes) p &lt;- ggplot(gm, aes(gdpPercap, lifeExp)) p &lt;- p + scale_x_log10() p &lt;- p + aes(col=continent) + geom_point() + geom_smooth(lwd=2, se=FALSE) p + theme_excel() p + theme_excel() + scale_colour_excel() p + theme_gdocs() + scale_colour_gdocs() p + theme_stata() + scale_colour_stata() p + theme_wsj() + scale_colour_wsj() p + theme_economist() p + theme_fivethirtyeight() p + theme_tufte() Finally, to add custom colors use scale_color_manual p + theme_tufte() + scale_color_manual(values = c(&quot;red&quot;, &quot;orange&quot;, &quot;yellow&quot;, &quot;green&quot;, &quot;blue&quot;)) "]
]
